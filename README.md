# 凝集度と結合度

## 時間的凝集

時間的凝集の関数は、具体的な処理を書くのではない。<br>
極力機能的凝集の関数を実行することに徹するべき。

## 論理的凝集になるケース

ユースケースが異なるが、処理が似ている実装を DRY にする時に気をつけなければならない<br>
最初は Usecase1 だけを想定すればよかったが、その関数をそのまま Usecase2 を想定すると論理的凝集になる。<br>

```ts
function usecase1() {
  a();
  b();
  c();
  d();
}
```

```diff
- function usecase1(){
+ function usecase2(){
  a();
  b();
  // usecase1のときだけ実行
+ if (isUsecase1){
  c();
+ }
  d();
}
```

### 論理的凝集を回避する方法

ユースケースごとに関数を定義する。<br>
これにより usecase を表現する関数が論理的凝集から時間的凝集になる。

```ts
function usecase1() {
  a();
  b();
  c();
  d();
}
```

```ts
function usecase2() {
  a();
  b();
  d();
}
```

### 論理的凝集を回避するメリット

論理的凝集を回避しつつ、実装詳細を機能的凝集として分離していくと、ユースケースを表現するレイヤーから条件分岐が消える。<br>
ユースケースの可読性が大幅に向上する。そのユースケースで必要な処理だけが書かれるため。<br>
また類似したユースケースが生まれた場合に、他のユースケースからコピペで作れるようになる。

```ts
function usecase2() {
  a();
  b();
  d();
}
```

```ts
// usecase2からusecase3は簡単につくれる。
function usecase3() {
  a();
  b();
}
```

論理的凝集を回避することで単一責任にもなる。
